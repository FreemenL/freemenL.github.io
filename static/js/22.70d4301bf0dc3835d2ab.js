(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{"./node_modules/_webpack@4.27.1@webpack/buildin/global.js":function(e,t,n){e.exports=n("dll-reference _dll_dllLibrary__pro")(19)},"./src/pages/Rules/web/index.tsx":function(e,t,n){"use strict";n.r(t);var a,o=n("./node_modules/_tslib@1.14.1@tslib/tslib.es6.js"),c=n("./node_modules/_react@16.8.2@react/index.js"),s=n.n(c),r=n("./node_modules/_emptyd@0.1.7@emptyd/EcodeHighlight/index.tsx"),o=(a=c.Component,o.d(m,a),m.prototype.render=function(){return s.a.createElement(s.a.Fragment,null,s.a.createElement("h1",{className:"e-title"}," 代码书写约定规范 "),s.a.createElement("p",{className:"empty-line-content"},"样式:"),s.a.createElement("p",{className:"empty-line-content"},"1、less: className的单词之间以",s.a.createElement("code",{className:"empty-code"},"“-”"),"连接,如",s.a.createElement("code",{className:"empty-code"},"empty-tree-content;")," ","相同的样式值多次使用到请使用变量（less 变量写法如：",s.a.createElement("code",{className:"empty-code"}," @base-padding:10px "),"）;"),s.a.createElement("p",{className:"empty-line-content"},"2、样式尽可能的用类选择器代替 标签选择器， 减少渲染引擎查找的过程"),s.a.createElement("p",{className:"empty-line-content"},"js:"),s.a.createElement("p",{className:"empty-line-content"},"1、变量名和普通函数名如果是多个单词,请使用",s.a.createElement("code",{className:"empty-code"},"小驼峰"),"格式如myName，构造函数名和 class 类名,请以 首字母大写、多个单词",s.a.createElement("code",{className:"empty-code"},"大驼峰"),"，如MyComponent;"),s.a.createElement("p",{className:"empty-line-content"},"2、声明函数参数超过 3 个时，请使用对象参数形式，如"," ",s.a.createElement("code",{className:"empty-code"},"showMyNames(show,isBox,byElement)"),",",s.a.createElement("code",{className:"empty-code"},"showMyDreams(","{show,isBox,byElement,allData}",")")),s.a.createElement("p",{className:"empty-line-content"},"3、导入方式",s.a.createElement("code",{className:"empty-code"},"import 和 require ")," 并行时",s.a.createElement("code",{className:"empty-code"},"先写import")),s.a.createElement("p",{className:"empty-line-content"},"4、条件判断",s.a.createElement("code",{className:"empty-code"},"先写可能性较大的")," , 并在适当的情境下用",s.a.createElement("code",{className:"empty-code"},"策略模式"),"代替 大量if else 嵌套的写法,增强代码可读性 降低维护成本"),s.a.createElement("p",{className:"empty-line-content"},"5、删除元素的时候要删除其绑定的事件 否则会存在",s.a.createElement("code",{className:"empty-code"},"内存泄漏"),"的问题"),s.a.createElement("p",{className:"empty-line-content"},"6、dom操作",s.a.createElement("code",{className:"empty-code"},"读写分离")," 避免不必要的dom回流和重绘"),s.a.createElement("p",{className:"empty-line-content"},"7、",s.a.createElement("code",{className:"empty-code"},"单例模式")," new操作符往往意味着资源的分配 ，因此我们应该在一开始的时候就创建对象，以后尽量使用同一个对象， 我们应该尽量减少 { } 的使用，就像减少new一样。因此在函数返回值中我们可以使用一个全局的变量去替代每次都创建一个返回值对象"),s.a.createElement("p",{className:"empty-line-content"},"8、清除[数组]的时候使用[数组].length=0,的方式，避免给其从新赋值为[]"),s.a.createElement("p",{className:"empty-line-content"},"9、setTimeOut中的function用变量保存，避免用bind 或者IIFE的方式获取this，使函数得到重用，而不是每次在运行的时候都会创建一个对象"),s.a.createElement("p",{className:"empty-line-content"},"react:"),s.a.createElement("p",{className:"empty-line-content"},"1、禁用组件生命周期函数：",s.a.createElement("code",{className:"empty-code"},"componentWillMount、componentWillReceiveProps、componentWillUpdate"),"因为这些可能在以后 react 中被废弃的函数;"),s.a.createElement("p",{className:"empty-line-content"},"2、ref 属性禁用字符串方式, 如禁用",s.a.createElement("code",{className:"empty-code"},'<div ref="myBox"></div>'),"，推荐用法"," ",s.a.createElement("code",{className:"empty-code"},"React.createRef()")),s.a.createElement("p",{className:"empty-line-content"},"3、组件内跟setState无关的属性，请不要写进 state中"),s.a.createElement("p",{className:"empty-line-content"},"4、给节点设置合理的key值 减小",s.a.createElement("code",{className:"empty-code"},"dom diff"),"时的开销和避免出错"),s.a.createElement("p",{className:"empty-line-content"},"5、通过chrome 扩展工具 识别不必要的渲染，将经常更新的区域提取为孤立的组件"),s.a.createElement("p",{className:"empty-line-content"},"6、避免将新对象作为 props 传递,如下："),s.a.createElement(r.a,{language:"tsx"},'\n            //  错误写法\n            class Description extends Component {\n              render() {\n                const i = {\n                  value: "i"\n                };\n                return (\n                  <p>\n                    <I i={i} />\n                    <Am />\n                    <A />\n                    <Profession profession={this.props.description} />\n                  </p>\n                );\n              }\n            }  \n            //正确写法\n            class Description extends Component {\n              i = {\n                value: "i"\n              };\n              render() {\n                return (\n                  <p>\n                   <I i={this.i} />\n                   <Am /> \n                   <A />\n                   <Profession profession={this.props.description} />\n                  </p>\n                );\n              }\n            }           \n          '),s.a.createElement("p",{className:"empty-line-content"},"7、巧用",s.a.createElement("code",{className:"empty-code"},"shouldComponentUpdate 或者 PureComponent ")," ","避免不必要的渲染"),s.a.createElement("p",{className:"empty-line-content"},"8、导入",s.a.createElement("code",{className:"empty-code"},"echarts lodash"),"等第三方库的时候请按需导入 具体方法可参考其文档"),s.a.createElement("p",{className:"empty-line-content"},"9、先导入",s.a.createElement("code",{className:"empty-code"},"第三方模块")," 自定义模块后导入"),s.a.createElement("h1",{className:"e-title"}," 静态资源"),s.a.createElement("p",{className:"empty-line-content"},"1、衡量小文件可进行打包处理的，统一放 @public 目录，如小图片在"," ",s.a.createElement("code",{className:"empty-code"},"@public/images")),s.a.createElement("p",{className:"empty-line-content"},"2、较大文件，不宜打包处理的，统一放static目录，且要以",s.a.createElement("code",{className:"empty-code"},'<img src="../../static/images/my.png"/>'),"方式使用"),s.a.createElement("h1",{className:"e-title"}," 通用组件 @components/**/*.tsx"),s.a.createElement("p",{className:"empty-line-content"},"1、一个组件就是一个文件夹，文件夹命名与组件命名相同，里面有对应的",s.a.createElement("code",{className:"empty-code"},"index.tsx")," （必需文件）和"," ",s.a.createElement("code",{className:"empty-code"},"style.less"),", 如 EFormHoc 组件。"),s.a.createElement(r.a,{language:"tsx"},"\n            import React,{Component}from 'react';\n            import { Form } from 'antd';\n            import freetool from 'freetool';\n            import autobind from 'autobind-decorator';\n\n            import { emptyFormConfig } from '../constant';\n            import EwapperHoc from '../EwapperHoc';\n            import EformIndex from '../Eform/index';\n            \n            const { mergeConfig } = freetool;\n            const {component:Eform} = EformIndex;\n            \n            \n            function EFormHoc(this:any,EformConfig,pattern){\n              const that = this;\n              let defaultProps = mergeConfig(emptyFormConfig.call(this),(EformConfig&&pattern==\"edit\")?EformConfig.call(this):(EformConfig&&EformConfig(pattern)));\n              @autobind\n              class  EFormWrapper extends Component<any>{\n                Eform\n                Ewapper\n                static displayName=\"EFormHoc(EFormWrapper)\"\n                static defaultProps = defaultProps\n                constructor(props){\n                  super(props)\n                  this.Eform = Eform.bind(this);\n                  this.Ewapper = EwapperHoc({Rowlayout:this.props.Rowlayout})\n                }\n                getElement(){\n                    const SearchItem = this.Eform\n                    return this.props.searchPanel?(<SearchItem/>):null;\n                }\n                handleSearch(e){\n                   if(!this.props.searchPanel.submit){throw ReferenceError(\"EFormHoc params must be have submit props！\")}\n                   this.props.searchPanel.submit.call(this,e,that.props);\n                }\n                handleReset(){\n                   this.props.form.resetFields();\n                }\n                render(){\t\t\n                      return(\n                        <this.Ewapper>\n                           {this.getElement()}\n                        </this.Ewapper>\n                      )\n                }\n              }\n              return Form.create()(EFormWrapper)\n            }\n            \n            export default{\n              name:\"EFormHoc\",\n              component:EFormHoc\n            }            \n          "),s.a.createElement("p",{className:"empty-line-content"},"2、必须以如下方式导出组件"),s.a.createElement(r.a,{language:"tsx"},'\n            export default{\n              name:"EFormHoc",\n              component:EFormHoc\n            }            \n          '),s.a.createElement("h1",{className:"e-title"}," 系统路由 @pages/**/router.ts （新建页面）"),s.a.createElement("p",{className:"empty-line-content"},"1、在 ",s.a.createElement("code",{className:"empty-code"},"@pages"),"目录下新建页面目录 并新建一个组件 *.tsx"),s.a.createElement("p",{className:"empty-line-content"},"2、路由用 ",s.a.createElement("code",{className:"empty-code"},"require.context")," ","做了去中心化处理,要求按如下方式导出"),s.a.createElement(r.a,{language:"tsx"},"\n            export default [\n              {\n                //匹配的路径\n                path:'/home/rules/intro',\n                //组件相对pages目录的路径\n                component:\"Rules/intro/index\",\n              },\n              {\n                path:'/home/rules/web',\n                component:\"Rules/web/index\",\n              },\n              {\n                path:'/home/rules/mobile',\n                component:\"Rules/mobile/index\",\n              }\n            ]      \n          "),s.a.createElement("h1",{className:"e-title"}," ","全局状态管理 @store/** （用的react-redux+redux-saga中间件）并进行了简单的封装"),s.a.createElement("p",{className:"empty-line-content"},s.a.createElement("code",{className:"empty-code"},"以登陆为例 梳理一个流程")),s.a.createElement("p",{className:"empty-line-content"},"1、在 ",s.a.createElement("code",{className:"empty-code"},"@store/action-types"),"目录下"," ",s.a.createElement("code",{className:"empty-code"},"index.ts"),"中新建action的type"),s.a.createElement(r.a,{language:"tsx"},'\n            // 登录相关\n            export const  LOGIN_REQUEST = "LOGIN_REQUEST";\n            export const  LOGIN_SUCCESS = "LOGIN_SUCCESS";\n            export const  LOGIN_ERROR = "LOGIN_ERROR";    \n          '),s.a.createElement("p",{className:"empty-line-content"},"2、在 ",s.a.createElement("code",{className:"empty-code"},"@reducers"),"目录下 新建 user.reducer.ts"),s.a.createElement(r.a,{language:"tsx"},'\n            // 登录相关\n            import * as types from \'../action-types\';\n            //函数名称要求以state_开头 action函数名结尾  此处为 state_doLogin \n            export const state_doLogin = (state={token:"",error:""},action)=>{\n              switch(action.type){\n                case types.LOGIN_SUCCESS:\n                  return { ...state,token:action.token }\n                case types.LOGIN_ERROR:\n                  return { ...state,error:action.error }\n                default:\n                  return state;\n              }\n            }    \n          '),s.a.createElement("p",{className:"empty-line-content"},"3、用HOC的思想对",s.a.createElement("code",{className:"empty-code"},"react-redux中的connect 函数"),"做了一层逻辑抽象 ，不必在每个子组件中都用 connect 去操作store"),s.a.createElement("p",null,"只需在 ",s.a.createElement("code",{className:"empty-code"},"@connect/controller.ts中进行一次配置，如下")," "),s.a.createElement(r.a,{language:"tsx"},'\n          const controller = { //key: action-type value:action函数名\n            LOGIN: "doLogin",\n          };\n          export default controller;\n        '),s.a.createElement("p",{className:"empty-line-content"},"4 、在",s.a.createElement("code",{className:"empty-code"},"@actions"),"目录下新建相应的action操作函数"),s.a.createElement(r.a,{language:"tsx"},"\n          import * as types from '../action-types';\n          export default {\n            doLogin(username,password){\n              return {type:types.LOGIN_REQUEST,username,password}\n            },\n            logout(){\n              return {type:types.LOGOUT_REQUEST}\n            }\n          }          \n        "),s.a.createElement("p",{className:"empty-line-content"},"5、回到组件中"),s.a.createElement(r.a,{language:"tsx"},"\n          import React, { Component } from 'react';\n          ...\n    \n          // 配置action 函数\n          @connectAid([Actions.LOGIN])\n          //在组件的props 中便能获取到action函数和所有的状态 \n          class doLogin extends Component<any, any>{\n              refForm\n              constructor(props) {\n                 ...\n              }\n              validataFunc(registerForm){\n                  ...\n              }\n              handleSubmit(event){\n                  ...\n                  //派发action\n                  this.props.Actions.doLogin('username',1234);\n              }\n              render() {\n                  return (\n                     ...\n                  )\n              }\n          }\n          \n          export default doLogin;              \n        "),s.a.createElement("p",{className:"empty-line-content"},"6、关于",s.a.createElement("code",{className:"empty-code"},"异步action")," 我们用的",s.a.createElement("code",{className:"empty-code"},"redux-saga"),"来做的处理"),s.a.createElement(r.a,{language:"tsx"},"\n          import { all, call ,put, takeEvery } from \"redux-saga/effects\";\n          import * as types from '../action-types';\n          import { push } from 'connected-react-router'\n          import service from \"@service/load-service\";\n          \n          interface Login{\n            type:string,\n            username:string,\n            password:string|number\n          }\n          \n          function* login(){\n            yield takeEvery(types.LOGIN_REQUEST,function*({type,username,password}:Login){\n              try{\n                // 接口调用\n                let token = yield call(service.system.login,username,password);\n                yield put({type:types.LOGIN_SUCCESS,token});\n                yield put(push('/home/home'));\n                return token;\n               }catch(error){\n                put({type:types.LOGIN_ERROR,error});\n               }\t\n            });\n          \n          }\n          \n          export function* rootSaga({dispatch,getState}){\n            yield all([login()])\n          }                        \n        "),s.a.createElement("h1",{className:"e-title"}," 接口调用规范 @service/** "),s.a.createElement("p",{className:"empty-line-content"},"1、在",s.a.createElement("code",{className:"empty-code"},"@service")," 目录下新建 *.api.ts"),s.a.createElement(r.a,{language:"tsx"},'\n          export default {\n            //命名空间  业务模块名称\n            namespace:"system",\n            // 定义接口函数 \n            apis:{\n              login(username,password){\n                return new Promise((resolve,reject)=>{\n                  setTimeout(()=>{\n                    resolve(username+password);\n                  },1000)\n                })\n              }\n            }\n          }                  \n        '),s.a.createElement("p",{className:"empty-line-content"},"2 、调用"),s.a.createElement(r.a,{language:"tsx"},'\n          ...\n          import service from "@service/load-service";\n          \n          ...\n          function* login(){\n            yield takeEvery(types.LOGIN_REQUEST,function*({type,username,password}:Login){\n              try{\n                // 接口调用\n                let token = yield call(service.system.login,username,password);\n                ...\n               }catch(error){\n                ...\n               }\t\n            });\n          \n          }\n          \n          ...                      \n        '))},m);function m(){return null!==a&&a.apply(this,arguments)||this}t.default=o}}]);